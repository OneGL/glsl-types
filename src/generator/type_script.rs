use super::common;
use crate::{
  log::{print_level, Level},
  utils::get_shader_type::{get_shader_type, ShaderType},
  write_file,
};
use glsl::syntax::TypeSpecifierNonArray;

pub fn generate_types_file(
  content: String,
  file_path: &std::path::PathBuf,
  output_folder: &std::path::PathBuf,
) -> bool {
  let shader_type = get_shader_type(file_path).unwrap();
  let shader_data = common::extract_shader_data(&content, shader_type);

  // Show a warning if the vertex shader has more than 16 attributes (This is webgl2)
  if shader_data.ins.len() > 16 && shader_data.shader_type == ShaderType::Vertex {
    print_level(Level::WARN);
    println!(
      "The vertex shader has more than 16 attributes. This can cause issues in some devices."
    );
  }

  let mut output_file = String::new();
  output_file.push_str("// DO NOT EDIT THIS FILE\n");
  output_file.push_str("// This file is generated by glsl-types\n\n");

  output_file.push_str(&format!("const SOURCE = /* glsl */ `{}`;\n\n", &content));

  let output_file_name = file_path.file_stem().unwrap().to_str().unwrap();
  let output_type_name = common::capitalize_first_letter(output_file_name);

  let uniforms = shader_data
    .uniforms
    .iter()
    .map(|value| {
      format!(
        r#"    {}: "{}","#,
        &value.identifier,
        convert_glsl_to_ts_label(&value.type_label)
      )
    })
    .collect::<Vec<String>>()
    .join("\n");

  let ins = shader_data
    .ins
    .iter()
    .map(|value| {
      format!(
        r#"    {}: "{}","#,
        &value.identifier,
        convert_glsl_to_ts_label(&value.type_label)
      )
    })
    .collect::<Vec<String>>()
    .join("\n");

  let outs = shader_data
    .outs
    .iter()
    .map(|value| {
      format!(
        r#"    {}: "{}","#,
        &value.identifier,
        convert_glsl_to_ts_label(&value.type_label)
      )
    })
    .collect::<Vec<String>>()
    .join("\n");

  // Export a type that contains all the uniforms
  output_file.push_str(&format!(
    r#"

export const {} = {{
  uniforms: {{
{}
  }},
  ins: {{
{}
  }},
  outs: {{
{}
  }},
  source: SOURCE
}};

"#,
    output_type_name, uniforms, ins, outs
  ));

  let output_file_path = output_folder.join(format!("{}.ts", output_file_name));
  // std::fs::write(output_file_path, output_file).unwrap();
  write_file(output_file_path.to_str().unwrap(), output_file.as_str());

  return true;
}

fn convert_glsl_to_ts_label(uniform: &TypeSpecifierNonArray) -> String {
  let result = match uniform {
    TypeSpecifierNonArray::Float => "float",
    TypeSpecifierNonArray::Vec2 => "vec2",
    TypeSpecifierNonArray::Vec3 => "vec3",
    TypeSpecifierNonArray::Vec4 => "vec4",

    TypeSpecifierNonArray::Int => "int",
    TypeSpecifierNonArray::IVec2 => "ivec2",
    TypeSpecifierNonArray::IVec3 => "ivec3",
    TypeSpecifierNonArray::IVec4 => "ivec4",

    TypeSpecifierNonArray::UInt => "uint",
    TypeSpecifierNonArray::UVec2 => "uvec2",
    TypeSpecifierNonArray::UVec3 => "uvec3",
    TypeSpecifierNonArray::UVec4 => "uvec4",

    TypeSpecifierNonArray::Bool => "bool",
    TypeSpecifierNonArray::BVec2 => "bvec2",
    TypeSpecifierNonArray::BVec3 => "bvec3",
    TypeSpecifierNonArray::BVec4 => "bvec4",

    TypeSpecifierNonArray::Mat2 => "mat2",
    TypeSpecifierNonArray::Mat3 => "mat3",
    TypeSpecifierNonArray::Mat4 => "mat4",
    _ => "UNKNOWN",
  };

  return result.to_string();
}
