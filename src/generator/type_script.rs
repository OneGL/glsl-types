use super::common;
use glsl::syntax::TypeSpecifierNonArray;

pub fn generate_ts_types_file(file_path: &std::path::PathBuf, output_folder: &std::path::PathBuf) {
  let file = std::fs::read_to_string(&file_path).unwrap();
  let uniforms = common::extract_uniforms(&file);

  let mut output_file = String::new();
  output_file.push_str("// DO NOT EDIT THIS FILE\n");
  output_file.push_str("// This file is generated by glsl-types\n\n");

  output_file.push_str(&format!("const SHADER_SOURCE = `{}`;\n\n", &file));

  // Define the types for each uniform at the top of the file
  for uniform in &uniforms {
    output_file.push_str(&format!(
      "type {} = {};\n",
      uniform.name,
      convert_uniform_to_ts(&uniform.uniform_type)
    ));
  }

  output_file.push_str("\n");

  let output_file_name = file_path.file_stem().unwrap().to_str().unwrap();
  let output_type_name = common::capitalize_first_letter(output_file_name);

  // Create program uniforms type
  let uniforms_type = format!("{}Uniforms", output_type_name);
  output_file.push_str(&format!("export type {} = {{\n", uniforms_type));
  for uniform in &uniforms {
    output_file.push_str(&format!("    {}: {};\n", &uniform.name, &uniform.name));
  }
  output_file.push_str("};");
  output_file.push_str("\n\n");

  // Export a type that contains all the uniforms
  output_file.push_str(&format!("export type {} = {{\n", output_type_name));
  output_file.push_str(&format!("    uniformTypes: {};\n", uniforms_type));
  output_file.push_str("    uniforms: {\n");
  for uniform in &uniforms {
    output_file.push_str(&format!(
      "        {}: \"{}\";\n",
      &uniform.name,
      convert_uniform_to_ts_label(&uniform.uniform_type)
    ));
  }
  output_file.push_str("    };\n");
  output_file.push_str("    shaderSource: typeof SHADER_SOURCE;\n");
  output_file.push_str("};\n");

  let output_file_path = output_folder.join(format!("{}.ts", output_file_name));
  std::fs::write(output_file_path, output_file).unwrap();
}

fn convert_uniform_to_ts(uniform: &TypeSpecifierNonArray) -> String {
  let result =  match uniform {
        TypeSpecifierNonArray::Float => "number",
        TypeSpecifierNonArray::Vec2 => "[number, number]",
        TypeSpecifierNonArray::Vec3 => "[number, number, number]",
        TypeSpecifierNonArray::Vec4 => "[number, number, number, number]",

        TypeSpecifierNonArray::Int => "number",
        TypeSpecifierNonArray::IVec2 => "[number, number]",
        TypeSpecifierNonArray::IVec3 => "[number, number, number]",
        TypeSpecifierNonArray::IVec4 => "[number, number, number, number]",

        TypeSpecifierNonArray::UInt => "number",
        TypeSpecifierNonArray::UVec2 => "[number, number]",
        TypeSpecifierNonArray::UVec3 => "[number, number, number]",
        TypeSpecifierNonArray::UVec4 => "[number, number, number, number]",

        TypeSpecifierNonArray::Bool => "boolean",
        TypeSpecifierNonArray::BVec2 => "[boolean, boolean]",
        TypeSpecifierNonArray::BVec3 => "[boolean, boolean, boolean]",
        TypeSpecifierNonArray::BVec4 => "[boolean, boolean, boolean, boolean]",

        TypeSpecifierNonArray::Mat2 => "[number, number, number, number]",
        TypeSpecifierNonArray::Mat3 => "[number, number, number, number, number, number, number, number, number]",
        TypeSpecifierNonArray::Mat4 => "[number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number]",
        _ => "UNKNOWN"
    };

  return result.to_string();
}

fn convert_uniform_to_ts_label(uniform: &TypeSpecifierNonArray) -> String {
  let result = match uniform {
    TypeSpecifierNonArray::Float => "float",
    TypeSpecifierNonArray::Vec2 => "vec2",
    TypeSpecifierNonArray::Vec3 => "vec3",
    TypeSpecifierNonArray::Vec4 => "vec4",

    TypeSpecifierNonArray::Int => "int",
    TypeSpecifierNonArray::IVec2 => "ivec2",
    TypeSpecifierNonArray::IVec3 => "ivec3",
    TypeSpecifierNonArray::IVec4 => "ivec4",

    TypeSpecifierNonArray::UInt => "uint",
    TypeSpecifierNonArray::UVec2 => "uvec2",
    TypeSpecifierNonArray::UVec3 => "uvec3",
    TypeSpecifierNonArray::UVec4 => "uvec4",

    TypeSpecifierNonArray::Bool => "bool",
    TypeSpecifierNonArray::BVec2 => "bvec2",
    TypeSpecifierNonArray::BVec3 => "bvec3",
    TypeSpecifierNonArray::BVec4 => "bvec4",

    TypeSpecifierNonArray::Mat2 => "mat2",
    TypeSpecifierNonArray::Mat3 => "mat3",
    TypeSpecifierNonArray::Mat4 => "mat4",
    _ => "UNKNOWN",
  };

  return result.to_string();
}
