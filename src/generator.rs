use crate::uniforms::{Uniform, UniformType};

fn capitalize_first_letter(s: &str) -> String {
    s.chars().next().unwrap().to_uppercase().collect::<String>() + &s[1..]
}

pub fn generate_ts_types_file(file_path: std::path::PathBuf, output_folder: std::path::PathBuf) {
    let file = std::fs::read_to_string(&file_path).unwrap();
    let uniforms = extract_uniforms(file);

    let mut output_file = String::new();
    output_file.push_str("// DO NOT EDIT THIS FILE\n");
    output_file.push_str("// This file is generated by glsl-types\n\n");

    // Define the types for each uniform at the top of the file
    for uniform in &uniforms {
        output_file.push_str(&format!(
            "type {} = {};\n",
            uniform.name,
            uniform.uniform_type.to_ts_type()
        ));
    }

    output_file.push_str("\n");

    let output_file_name = file_path.file_stem().unwrap().to_str().unwrap();
    let output_type_name = capitalize_first_letter(output_file_name);

    // Export a type that contains all the uniforms
    output_file.push_str(&format!("export type {} = {{\n", output_type_name));
    output_file.push_str("    uniforms: {\n");
    for uniform in uniforms {
        output_file.push_str(&format!("        {}: {};\n", uniform.name, uniform.name));
    }
    output_file.push_str("    };\n");
    output_file.push_str("};\n");

    let output_file_path = output_folder.join(format!("{}.ts", output_file_name));
    std::fs::write(output_file_path, output_file).unwrap();
}

fn extract_uniforms(file: String) -> Vec<Uniform> {
    let mut uniforms = Vec::new();

    let file = remove_comments(file);
    let file = file.replace("\n", "");

    let words = file.split_whitespace();

    // Check each word for words with the ";" character and convert those words into multiple words
    let words: Vec<&str> = words
        .map(|word| word.split(";").collect::<Vec<&str>>())
        .flatten()
        .collect();

    let mut i = 0;
    while i < words.len() {
        if words[i] == "uniform" {
            let uniform_type = words[i + 1];
            let uniform_name = words[i + 2].split(";").collect::<Vec<&str>>()[0];

            let uniform_type = match UniformType::from_str(uniform_type) {
                Ok(uniform_type) => uniform_type,
                Err(_) => {
                    println!(
                        "Unknown uniform type: {}. Skipping types for uniform: {}",
                        uniform_type, uniform_name
                    );

                    i += 1;
                    continue;
                }
            };

            let uniform = Uniform {
                name: uniform_name.to_string(),
                uniform_type: uniform_type,
            };

            uniforms.push(uniform);
        }
        i += 1;
    }

    return uniforms;
}

fn remove_comments(file: String) -> String {
    let mut result = String::new();
    let mut chars = file.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '/' {
            if let Some(&'/') = chars.peek() {
                while let Some(c) = chars.next() {
                    if c == '\n' {
                        break;
                    }
                }
            } else if let Some(&'*') = chars.peek() {
                while let Some(c) = chars.next() {
                    if c == '*' {
                        if let Some(&'/') = chars.peek() {
                            chars.next();
                            break;
                        }
                    }
                }
            } else {
                result.push(c);
            }
        } else {
            result.push(c);
        }
    }

    return result;
}
